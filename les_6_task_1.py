# 3 урок 9 задача
# Найти максимальный элемент среди минимальных элементов столбцов матрицы.
# Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)] on win32

import random
from sys import getsizeof
import numpy

SIZE_N = 300
SIZE_M = 500
MIN_ITEM = 0
MAX_ITEM = 1000


def memory_needed(variables: dict):
    """
    Данная функция принимает в себя словарь со всеми переменными и возвращает количество расходуемой переменными памяти
    :param variables:
    :return:
    """
    res = 0
    for var_name, value in variables.items():
        res += getsizeof(value)
    return res


def mem_matrix_min_ver_1(matrix):
    """
    Данный вариант сделал в рамках домашнего задания к уроку №3.
    Занимает памяти 232 байта(возможно?) при ширине матрицы 3, а высоте 5.
    Занимает памяти 632 байта(возможно?) при ширине матрицы 30, а высоте 50.
    Занимает памяти 4376 байта(возможно?) при ширине матрицы 300, а высоте 500.
    :param matrix:
    :return:
    """
    min_in_col = 0
    max_in_min = 0

    for row in range(len(matrix[0])):
        for col in range(len(matrix)):
            if col == 0 or matrix[col][row] < min_in_col:
                min_in_col = matrix[col][row]

        if max_in_min < min_in_col:
            max_in_min = min_in_col

    return memory_needed(locals())


def mem_matrix_min_ver_2(matrix):
    """
    Данный вариант пришел после долгих переделок. В целом он может положительно влиять на асимптотику,
    но памяти кушает больше.
    Занимает памяти 316 байта(возможно?) при ширине матрицы 3, а высоте 5.
    Занимает памяти 1324 байта(возможно?) при ширине матрицы 30, а высоте 50.
    Занимает памяти 10860 байта(возможно?) при ширине матрицы 300, а высоте 500.
    :param matrix:
    :return:
    """
    min_in = []

    for row in zip(*matrix):
        min_in.append(min(row))

    max_in_min = max(min_in)

    return memory_needed(locals())


def mem_matrix_min_ver_3(matrix):
    """
    Данный вариант логически перешел из второго. Переменные расходуются минимально (а отследить занятую память
    генератором не получится охохо) поэтому испытываем прирост в запасе памяти в 1,5-2 раза(на малых значениях matrix)
    по сравнению с предыдущими.
    Занимает памяти 148 байта(возможно?) при ширине матрицы 3, а высоте 5.
    Занимает памяти 548 байта(возможно?) при ширине матрицы 30, а высоте 50.
    Занимает памяти 4292 байта(возможно?) при ширине матрицы 300, а высоте 500.
    :param matrix:
    :return:
    """
    max_in_min = max([min(arr) for arr in zip(*matrix)])

    print(memory_needed({'zip': zip(*matrix)}))  # проверено, всего 56 байт при ширине матрицы 300, а высоте 500.
    print(memory_needed({'arr': [min(arr) for arr in
                                 zip(*matrix)]}))  # проверено, всего 2528 байт при ширине матрицы 300, а высоте 500.
    return memory_needed(locals())


"""
Вместо выводов:
Динамика расходования памяти нивелирует выигрыш 3го алгоритма перед 1м по памяти, поэтому можно сказать, что бОльшую 
часть памяти расходует именно сама матрица matrix .
Тем не менее т.к. во 2м случае используется вспомогательный массив, то увеличение памяти этим способом практически
линейна и не может конкурировать с 1м и 3м вариантом.
Тем не менее есть предположение, что расходование памяти 2м и 3м способом может быть схоже, но отображается по разному
т.к. расходуемая память в 3м алгоритме занимается в генераторе и на моменте проверки не видна. 
Это технически подтверждают дополнительные проверки структур данных 3го алгоритма.
В связи с этим можно вывести 1й алгоритм в фавориты.
"""

matrix = [[random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_N)] for _ in range(SIZE_M)]

print(mem_matrix_min_ver_1(matrix))
print(mem_matrix_min_ver_2(matrix))
print(mem_matrix_min_ver_3(matrix))
